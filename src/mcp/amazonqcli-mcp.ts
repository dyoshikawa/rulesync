import { readFile } from "node:fs/promises";
import { AiFileFromFilePathParams, AiFileParams, ValidationResult } from "../types/ai-file.js";
import { RulesyncMcpServer } from "../types/mcp.js";
import { RulesyncMcp } from "./rulesync-mcp.js";
import { ToolMcp } from "./tool-mcp.js";

/**
 * Configuration interface for Amazon Q CLI MCP servers
 */
export interface AmazonqcliMcpConfig {
  mcpServers: Record<string, AmazonqcliMcpServer>;
}

/**
 * Amazon Q CLI specific MCP server configuration
 */
export interface AmazonqcliMcpServer {
  command?: string;
  args?: string[];
  env?: Record<string, string>;
  timeout?: number;
  disabled?: boolean;
  autoApprove?: string[];
}

/**
 * AmazonqcliMcp class handles MCP (Model Context Protocol) configurations for Amazon Q Developer CLI.
 * Amazon Q CLI supports two configuration levels:
 * - Global: ~/.aws/amazonq/mcp.json (user-specific, not generated by this tool)
 * - Workspace: .amazonq/mcp.json (project-specific)
 */
export class AmazonqcliMcp extends ToolMcp {
  private config: AmazonqcliMcpConfig;

  constructor(params: AiFileParams & { config?: AmazonqcliMcpConfig }) {
    // Set config before calling super to ensure it's available for validation
    const config = params.config || { mcpServers: {} };

    // Create a modified params object without the config property for parent constructor
    const { config: _, ...parentParams } = params;

    // Generate file content if not provided
    const fileContent = params.fileContent || JSON.stringify(config, null, 2);

    super({
      ...parentParams,
      fileContent,
      validate: false, // Skip parent validation, we'll validate in our own method
    });

    this.config = config;

    // Perform validation after everything is initialized
    if (params.validate !== false) {
      const result = this.validate();
      if (!result.success) {
        throw result.error;
      }
    }
  }

  /**
   * Get the filename for Amazon Q CLI MCP configuration.
   * Returns the workspace-level configuration path.
   */
  getFileName(): string {
    return ".amazonq/mcp.json";
  }

  /**
   * Generate the content for Amazon Q CLI MCP configuration file.
   */
  async generateContent(): Promise<string> {
    return JSON.stringify(this.config, null, 2);
  }

  /**
   * Create an AmazonqcliMcp instance from a RulesyncMcp configuration.
   */
  static fromRulesyncMcp(rulesyncMcp: RulesyncMcp): AmazonqcliMcp {
    const rulesyncConfig = rulesyncMcp.toMcpConfig();
    const amazonqConfig: AmazonqcliMcpConfig = {
      mcpServers: {},
    };

    // Convert RulesyncMcp servers to Amazon Q CLI format
    for (const [serverName, server] of Object.entries(rulesyncConfig.mcpServers)) {
      // Check if this server should be included for Amazon Q CLI
      if (!shouldIncludeServerForTarget(server, "amazonqcli")) {
        continue;
      }

      const amazonqServer: AmazonqcliMcpServer = {};

      // Map standard MCP fields
      if (server.command) {
        // Ensure command is a string (RulesyncMcpServer can have string | string[])
        const command = Array.isArray(server.command) ? server.command[0] : server.command;
        if (command) {
          amazonqServer.command = command;
        }
        if (server.args) {
          amazonqServer.args = server.args;
        }
      }

      if (server.env) {
        amazonqServer.env = server.env;
      }

      // Amazon Q CLI specific fields
      if (server.timeout !== undefined) {
        amazonqServer.timeout = server.timeout;
      }

      if (server.disabled !== undefined) {
        amazonqServer.disabled = server.disabled;
      }

      // Map alwaysAllow to autoApprove (Amazon Q CLI naming)
      if (server.alwaysAllow) {
        amazonqServer.autoApprove = server.alwaysAllow;
      }

      amazonqConfig.mcpServers[serverName] = amazonqServer;
    }

    return new AmazonqcliMcp({
      baseDir: ".",
      relativeDirPath: ".amazonq",
      relativeFilePath: "mcp.json",
      fileContent: JSON.stringify(amazonqConfig, null, 2),
      config: amazonqConfig,
    });
  }

  /**
   * Load an AmazonqcliMcp configuration from a file.
   */
  static async fromFilePath(params: AiFileFromFilePathParams): Promise<AmazonqcliMcp> {
    const { filePath } = params;
    const fileContent = await readFile(filePath, "utf-8");
    const config: AmazonqcliMcpConfig = JSON.parse(fileContent);

    return new AmazonqcliMcp({
      baseDir: params.baseDir || ".",
      relativeDirPath: params.relativeDirPath,
      relativeFilePath: params.relativeFilePath,
      fileContent,
      config,
    });
  }

  /**
   * Validate the Amazon Q CLI MCP configuration.
   */
  validate(): ValidationResult {
    try {
      // Call parent validation first
      const parentResult = super.validate();
      if (!parentResult.success) {
        return parentResult;
      }

      // Validate configuration structure
      if (!this.config || typeof this.config !== "object") {
        return {
          success: false,
          error: new Error("Invalid configuration: config must be an object"),
        };
      }

      if (!this.config.mcpServers || typeof this.config.mcpServers !== "object") {
        return {
          success: false,
          error: new Error("Invalid configuration: mcpServers must be an object"),
        };
      }

      // Validate each server configuration
      for (const [serverName, server] of Object.entries(this.config.mcpServers)) {
        if (!server || typeof server !== "object") {
          return {
            success: false,
            error: new Error(`Invalid server configuration for "${serverName}": must be an object`),
          };
        }

        // Validate that server has either command (for local) or is disabled
        if (!server.command && !server.disabled) {
          return {
            success: false,
            error: new Error(
              `Server "${serverName}" must have a 'command' field or be marked as 'disabled'`,
            ),
          };
        }

        // Validate command is a string if present
        if (server.command && typeof server.command !== "string") {
          return {
            success: false,
            error: new Error(`Server "${serverName}": 'command' must be a string`),
          };
        }

        // Validate args is an array of strings if present
        if (server.args) {
          if (!Array.isArray(server.args)) {
            return {
              success: false,
              error: new Error(`Server "${serverName}": 'args' must be an array`),
            };
          }
          for (const arg of server.args) {
            if (typeof arg !== "string") {
              return {
                success: false,
                error: new Error(`Server "${serverName}": all args must be strings`),
              };
            }
          }
        }

        // Validate autoApprove is an array of strings if present
        if (server.autoApprove) {
          if (!Array.isArray(server.autoApprove)) {
            return {
              success: false,
              error: new Error(`Server "${serverName}": 'autoApprove' must be an array`),
            };
          }
          for (const tool of server.autoApprove) {
            if (typeof tool !== "string") {
              return {
                success: false,
                error: new Error(`Server "${serverName}": all autoApprove items must be strings`),
              };
            }
          }
        }

        // Validate timeout is a positive number if present
        if (server.timeout !== undefined) {
          if (typeof server.timeout !== "number" || server.timeout <= 0) {
            return {
              success: false,
              error: new Error(`Server "${serverName}": 'timeout' must be a positive number`),
            };
          }
        }

        // Validate disabled is a boolean if present
        if (server.disabled !== undefined && typeof server.disabled !== "boolean") {
          return {
            success: false,
            error: new Error(`Server "${serverName}": 'disabled' must be a boolean`),
          };
        }
      }

      return { success: true, error: null };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  }

  /**
   * Get the configuration object.
   */
  getConfig(): AmazonqcliMcpConfig {
    return this.config;
  }

  /**
   * Set the configuration object.
   */
  setConfig(config: AmazonqcliMcpConfig): void {
    this.config = config;
  }
}

/**
 * Helper function to check if a server should be included for Amazon Q CLI.
 * This is a simplified version of the logic from utils/mcp-helpers.ts
 */
function shouldIncludeServerForTarget(server: RulesyncMcpServer, target: string): boolean {
  // If server has no targets specified, include it for all tools
  if (!server.targets || server.targets.length === 0) {
    return true;
  }

  // Check if targets include "*" (all tools)
  if (server.targets.length === 1 && server.targets[0] === "*") {
    return true;
  }

  // Check if the specific tool is in the targets
  return server.targets.some((t) => t === target);
}
