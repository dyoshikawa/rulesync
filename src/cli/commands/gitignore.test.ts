import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { fileExists, readFileContent, writeFileContent } from "../../utils/file.js";
import { logger } from "../../utils/logger.js";
import { gitignoreCommand } from "./gitignore.js";

// Mock dependencies
vi.mock("../../utils/file.js");
vi.mock("../../utils/logger.js");

describe("gitignoreCommand", () => {
  const mockGitignorePath = "/workspace/.gitignore";

  beforeEach(() => {
    // Mock process.cwd to return a consistent path
    vi.spyOn(process, "cwd").mockReturnValue("/workspace");

    // Setup logger mocks
    vi.mocked(logger.info).mockImplementation(() => {});
    vi.mocked(logger.success).mockImplementation(() => {});

    // Setup file utility mocks
    vi.mocked(fileExists).mockResolvedValue(false);
    vi.mocked(readFileContent).mockResolvedValue("");
    vi.mocked(writeFileContent).mockResolvedValue(undefined);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe("when .gitignore does not exist", () => {
    it("should create a new .gitignore with all AI tool rules", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).not.toHaveBeenCalled();
      expect(writeFileContent).toHaveBeenCalledWith(
        mockGitignorePath,
        expect.stringContaining("# Generated by rulesync - AI tool configuration files"),
      );
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );
    });

    it("should include all expected AI tool patterns", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      // Check for key patterns
      expect(content).toContain("**/.amazonq/");
      expect(content).toContain("**/.cursor/");
      expect(content).toContain("**/.clinerules/");
      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.gemini/memories/");
      expect(content).toContain("**/.roo/rules/");
      expect(content).toContain("**/.aiexclude");
      expect(content).toContain("**/.mcp.json");
      expect(content).toContain("**/.warp/");
      expect(content).toContain("**/.codex/");
    });

    it("should format content properly with newline at end", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/\n$/); // Should end with newline
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
    });
  });

  describe("when .gitignore exists but is empty", () => {
    it("should add all rules to empty .gitignore", async () => {
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue("");

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).toHaveBeenCalledWith(
        mockGitignorePath,
        expect.stringContaining("# Generated by rulesync - AI tool configuration files"),
      );
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );
    });
  });

  describe("when .gitignore exists with existing content", () => {
    it("should append new rules to existing content", async () => {
      const existingContent = "node_modules/\n*.log\n";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain(existingContent.trim());
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
      expect(content).toMatch(/node_modules\/\n\*\.log\n\n# Generated by rulesync/);
    });

    it("should preserve existing content with proper spacing", async () => {
      const existingContent = "node_modules/\n*.log";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      // Should have double newline between existing content and new rules
      expect(content).toMatch(/\*\.log\n\n# Generated by rulesync/);
    });
  });

  describe("when some rules already exist", () => {
    it("should only add missing rules", async () => {
      const existingContent = `node_modules/
*.log
# Generated by rulesync - AI tool configuration files
**/.amazonq/
**/.cursor/`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      // Should contain existing content
      expect(content).toContain("node_modules/");
      expect(content).toContain("*.log");

      // Should not duplicate existing rules
      const amazonqMatches = content.match(/\*\*\/\.amazonq\//g);
      expect(amazonqMatches).toHaveLength(1);

      // Note: **/.cursor/ appears in two different patterns: **/.cursor/ and **/.cursor/mcp.json
      // So we should see it mentioned at least twice when all rules are added
      const cursorMatches = content.match(/\*\*\/\.cursor\//g);
      expect(cursorMatches).toBeDefined();
      expect(cursorMatches!.length).toBeGreaterThanOrEqual(1);

      // Should add missing rules
      expect(content).toContain("**/.clinerules/");
      expect(content).toContain("**/CLAUDE.md");
    });

    it("should report correct number of added rules", async () => {
      const existingContent = `# Generated by rulesync - AI tool configuration files
**/.amazonq/
**/.cursor/
**/.clinerules/`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      // Should report that fewer rules were added since some already existed
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );

      // Get the number from the log call
      const logCall = vi
        .mocked(logger.success)
        .mock.calls.find((call) => typeof call[0] === "string" && call[0].includes("Added"));
      expect(logCall).toBeDefined();

      // Extract number and verify it's less than total possible rules
      const match = logCall![0].match(/Added (\d+) rules/);
      expect(match).toBeDefined();
      const addedCount = parseInt(match![1]!, 10);
      expect(addedCount).toBeLessThan(53); // Total rules minus the 3 already present
    });
  });

  describe("when all rules already exist", () => {
    it("should report that .gitignore is up to date", async () => {
      // Create content with all the rules that gitignoreCommand would add
      const allRulesContent = `# Generated by rulesync - AI tool configuration files
**/.amazonq/
**/.github/copilot-instructions.md
**/.github/instructions/
**/.cursor/
**/.cursorignore
**/.clinerules/
**/.clineignore
**/CLAUDE.md
**/.claude/memories/
**/.claude/commands/
**/.claude/agents/
**/AGENTS.md
**/.agents/
**/.roo/rules/
**/.rooignore
**/.copilotignore
**/GEMINI.md
**/.gemini/memories/
**/.gemini/commands/
**/QWEN.md
**/.qwen/memories/
**/.aiexclude
**/.aiignore
**/.augmentignore
**/.kiro/steering/
**/.augment/rules/
**/.augment-guidelines
**/.junie/guidelines.md
**/.noai
**/.opencode/memories/
**/.opencode/commands/
**/opencode.json
**/.mcp.json
**/.cursor/mcp.json
**/.cline/mcp.json
**/.roo/mcp.json
**/.vscode/mcp.json
**/.github/commands/
**/.github/subagents/
**/.warp/
**/WARP.md
**/.codexignore
**/.codex/`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(allRulesContent);

      await gitignoreCommand();

      expect(logger.success).toHaveBeenCalledWith(".gitignore is already up to date");
      expect(writeFileContent).not.toHaveBeenCalled();
    });
  });

  describe("logging behavior", () => {
    it("should log each added rule (excluding comments)", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      // Should log the count of added rules
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );

      // Should log each individual rule (not comments)
      expect(logger.info).toHaveBeenCalledWith("  **/.amazonq/");
      expect(logger.info).toHaveBeenCalledWith("  **/.cursor/");
      expect(logger.info).toHaveBeenCalledWith("  **/CLAUDE.md");

      // Should not log comment lines
      expect(logger.info).not.toHaveBeenCalledWith(
        expect.stringContaining("# Generated by rulesync"),
      );
    });

    it("should not log rules that are comments", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      // Get all info log calls
      const infoLogCalls = vi.mocked(logger.info).mock.calls;

      // None should contain comments (lines starting with #)
      for (const call of infoLogCalls) {
        if (typeof call[0] === "string") {
          expect(call[0]).not.toMatch(/^\s*#/);
        }
      }
    });
  });

  describe("error handling", () => {
    it("should handle file existence check errors", async () => {
      vi.mocked(fileExists).mockRejectedValue(new Error("Permission denied"));

      await expect(gitignoreCommand()).rejects.toThrow("Permission denied");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).not.toHaveBeenCalled();
      expect(writeFileContent).not.toHaveBeenCalled();
    });

    it("should handle file read errors", async () => {
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockRejectedValue(new Error("Read error"));

      await expect(gitignoreCommand()).rejects.toThrow("Read error");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).not.toHaveBeenCalled();
    });

    it("should handle file write errors", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);
      vi.mocked(writeFileContent).mockRejectedValue(new Error("Write error"));

      await expect(gitignoreCommand()).rejects.toThrow("Write error");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).toHaveBeenCalled();
      expect(logger.success).not.toHaveBeenCalled();
    });
  });

  describe("path handling", () => {
    it("should use correct .gitignore path based on current working directory", async () => {
      const testCwd = "/different/path";
      vi.spyOn(process, "cwd").mockReturnValue(testCwd);
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(`${testCwd}/.gitignore`);
      expect(writeFileContent).toHaveBeenCalledWith(`${testCwd}/.gitignore`, expect.any(String));
    });
  });

  describe("content formatting", () => {
    it("should handle existing content with trailing whitespace", async () => {
      const existingContent = "node_modules/\n*.log   \n   ";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      // Should trim trailing whitespace before adding new content
      expect(content).toMatch(/\*\.log\n\n# Generated by rulesync/);
      expect(content).not.toContain("   \n\n");
    });

    it("should ensure proper line separation between existing and new content", async () => {
      const existingContent = "node_modules/";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      // Should have exactly two newlines between existing and new content
      expect(content).toMatch(/node_modules\/\n\n# Generated by rulesync/);
    });
  });
});
