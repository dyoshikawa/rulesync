import { join } from "node:path";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { setupTestDirectory } from "../../test-utils/test-directories.js";
import * as fileUtils from "../../utils/file.js";
import { logger } from "../../utils/logger.js";
import { gitignoreCommand } from "./gitignore.js";

vi.mock("../../utils/file.js");
vi.mock("../../utils/logger.js");

describe("gitignoreCommand", () => {
  let testDir: string;
  let cleanup: () => Promise<void>;
  let originalCwd: string;

  beforeEach(async () => {
    ({ testDir, cleanup } = await setupTestDirectory());
    originalCwd = process.cwd();
    process.chdir(testDir);
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await cleanup();
    vi.clearAllMocks();
  });

  it("should create new .gitignore with rulesync rules when file doesn't exist", async () => {
    vi.mocked(fileUtils.fileExists).mockResolvedValue(false);

    await gitignoreCommand();

    const expectedPath = join(testDir, ".gitignore");
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining("# Generated by rulesync - AI tool configuration files"),
    );
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining("**/.cursor/rules/"),
    );
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining("**/.github/copilot-instructions.md"),
    );

    expect(logger.success).toHaveBeenCalledWith(
      expect.stringMatching(/Added \d+ rules to \.gitignore:/),
    );
  });

  it("should append rules to existing .gitignore file", async () => {
    const existingContent = "node_modules/\n*.log\n";
    vi.mocked(fileUtils.fileExists).mockResolvedValue(true);
    vi.mocked(fileUtils.readFileContent).mockResolvedValue(existingContent);

    await gitignoreCommand();

    const expectedPath = join(testDir, ".gitignore");
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining(existingContent.trim()),
    );
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining("# Generated by rulesync - AI tool configuration files"),
    );
  });

  it("should not add duplicate rules", async () => {
    // Include all the rules that the command checks for
    const existingContent = `node_modules/
# Generated by rulesync - AI tool configuration files
**/.amazonq/rules/
**/.amazonq/mcp.json
**/.github/copilot-instructions.md
**/.github/instructions/
**/.cursor/rules/
**/.cursorignore
**/.clinerules/
**/.clineignore
**/CLAUDE.md
**/.claude/memories/
**/.claude/commands/
**/.claude/agents/
**/AGENTS.md
**/.agents/
**/.codexignore
**/.roo/rules/
**/.rooignore
**/.copilotignore
**/GEMINI.md
**/.gemini/memories/
**/.gemini/commands/
**/QWEN.md
**/.qwen/memories/
**/.aiexclude
**/.aiignore
**/.augmentignore
**/.kiro/steering/
**/.augment/rules/
**/.augment-guidelines
**/.junie/guidelines.md
**/.noai
**/.opencode/memories/
**/.opencode/commands/
**/opencode.json
**/.mcp.json
!.rulesync/.mcp.json
**/.cursor/mcp.json
**/.cline/mcp.json
**/.vscode/mcp.json
**/.codex/mcp-config.json
**/.gemini/settings.json
**/.qwen/settings.json
**/.roo/mcp.json
`;
    vi.mocked(fileUtils.fileExists).mockResolvedValue(true);
    vi.mocked(fileUtils.readFileContent).mockResolvedValue(existingContent);

    await gitignoreCommand();

    expect(logger.success).toHaveBeenCalledWith(".gitignore is already up to date");
    expect(fileUtils.writeFileContent).not.toHaveBeenCalled();
  });

  it("should add only missing rules", async () => {
    const existingContent = `node_modules/
**/.cursor/rules/
`;
    vi.mocked(fileUtils.fileExists).mockResolvedValue(true);
    vi.mocked(fileUtils.readFileContent).mockResolvedValue(existingContent);

    await gitignoreCommand();

    const expectedPath = join(testDir, ".gitignore");
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining(existingContent.trim()),
    );
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining("**/.github/copilot-instructions.md"),
    );
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.not.stringContaining("**/.cursor/rules/\n**/.cursor/rules/"),
    );
  });

  it("should include all expected rulesync-generated patterns", async () => {
    vi.mocked(fileUtils.fileExists).mockResolvedValue(false);

    await gitignoreCommand();

    const writeCall = vi.mocked(fileUtils.writeFileContent).mock.calls[0];
    const content = writeCall[1];

    // Check for key patterns
    expect(content).toContain("**/.amazonq/rules/");
    expect(content).toContain("**/.cursor/rules/");
    expect(content).toContain("**/.github/copilot-instructions.md");
    expect(content).toContain("**/CLAUDE.md");
    expect(content).toContain("**/.claude/memories/");
    expect(content).toContain("**/.roo/rules/");
    expect(content).toContain("**/.mcp.json");
    expect(content).toContain("!.rulesync/.mcp.json");
  });

  it("should log non-comment rules that are added", async () => {
    vi.mocked(fileUtils.fileExists).mockResolvedValue(false);

    await gitignoreCommand();

    // Should log success message about adding rules
    expect(logger.success).toHaveBeenCalledWith(
      expect.stringMatching(/Added \d+ rules to \.gitignore:/),
    );

    // Should log individual patterns (non-comments)
    expect(logger.info).toHaveBeenCalledWith("  **/.amazonq/rules/");
    expect(logger.info).toHaveBeenCalledWith("  **/.cursor/rules/");
    expect(logger.info).toHaveBeenCalledWith("  **/CLAUDE.md");
  });

  it("should handle empty existing .gitignore file", async () => {
    vi.mocked(fileUtils.fileExists).mockResolvedValue(true);
    vi.mocked(fileUtils.readFileContent).mockResolvedValue("");

    await gitignoreCommand();

    const expectedPath = join(testDir, ".gitignore");
    expect(fileUtils.writeFileContent).toHaveBeenCalledWith(
      expectedPath,
      expect.stringContaining("# Generated by rulesync - AI tool configuration files"),
    );
  });

  it("should properly format content with newlines", async () => {
    const existingContent = "node_modules/\n*.log";
    vi.mocked(fileUtils.fileExists).mockResolvedValue(true);
    vi.mocked(fileUtils.readFileContent).mockResolvedValue(existingContent);

    await gitignoreCommand();

    const writeCall = vi.mocked(fileUtils.writeFileContent).mock.calls[0];
    const content = writeCall[1];

    // Should have proper spacing between existing content and new rules
    expect(content).toContain("*.log\n\n# Generated by rulesync");
    expect(content).toMatch(/\n$/); // Should end with newline
  });
});
