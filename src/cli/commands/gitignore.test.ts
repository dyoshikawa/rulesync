import { join } from "node:path";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { setupTestDirectory } from "../../test-utils/test-directories.js";
import { fileExists, readFileContent } from "../../utils/file.js";
import { logger } from "../../utils/logger.js";
import { gitignoreCommand } from "./gitignore.js";

// Mock logger to suppress output during tests
vi.mock("../../utils/logger.js");

describe("gitignoreCommand", () => {
  let testDir: string;
  let cleanup: () => Promise<void>;

  beforeEach(async () => {
    ({ testDir, cleanup } = await setupTestDirectory());
    vi.spyOn(process, "cwd").mockReturnValue(testDir);

    // Setup logger mocks
    vi.mocked(logger.info).mockImplementation(() => {});
    vi.mocked(logger.success).mockImplementation(() => {});
  });

  afterEach(async () => {
    await cleanup();
    vi.clearAllMocks();
  });

  describe("when .gitignore does not exist", () => {
    it("should create a new .gitignore with all AI tool rules", async () => {
      const gitignorePath = join(testDir, ".gitignore");

      await gitignoreCommand();

      expect(await fileExists(gitignorePath)).toBe(true);
      const content = await readFileContent(gitignorePath);
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );
    });

    it("should include all expected AI tool patterns", async () => {
      const gitignorePath = join(testDir, ".gitignore");

      await gitignoreCommand();

      const content = await readFileContent(gitignorePath);

      // Check for key patterns
      expect(content).toContain("**/.amazonq/");
      expect(content).toContain("**/.cursor/");
      expect(content).toContain("**/.clinerules/");
      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.gemini/memories/");
      expect(content).toContain("**/.roo/rules/");
      expect(content).toContain("**/.aiignore");
      expect(content).toContain("**/.mcp.json");
      expect(content).toContain("**/.github/subagents/");
      expect(content).toContain("**/.github/prompts/");
      expect(content).toContain("**/.warp/");
      expect(content).toContain("**/.codex/");
    });

    it("should format content properly with newline at end", async () => {
      const gitignorePath = join(testDir, ".gitignore");

      await gitignoreCommand();

      const content = await readFileContent(gitignorePath);

      expect(content).toMatch(/\n$/); // Should end with newline
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
    });
  });

  describe("when .gitignore exists but is empty", () => {
    it("should add all rules to empty .gitignore", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, "", "utf-8");

      await gitignoreCommand();

      expect(await fileExists(gitignorePath)).toBe(true);
      const content = await readFileContent(gitignorePath);
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );
    });
  });

  describe("when .gitignore exists with existing content", () => {
    it("should append new rules to existing content", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const existingContent = "node_modules/\n*.log\n";
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, existingContent, "utf-8");

      await gitignoreCommand();

      const content = await readFileContent(gitignorePath);

      expect(content).toContain(existingContent.trim());
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
      expect(content).toMatch(/node_modules\/\n\*\.log\n\n# Generated by rulesync/);
    });

    it("should preserve existing content with proper spacing", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const existingContent = "node_modules/\n*.log";
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, existingContent, "utf-8");

      await gitignoreCommand();

      const content = await readFileContent(gitignorePath);

      // Should have double newline between existing content and new rules
      expect(content).toMatch(/\*\.log\n\n# Generated by rulesync/);
    });
  });

  describe("when some rules already exist", () => {
    it("should only add missing rules", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const existingContent = `node_modules/
*.log
# Generated by rulesync - AI tool configuration files
**/.amazonq/
**/.cursor/`;
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, existingContent, "utf-8");

      await gitignoreCommand();

      const content = await readFileContent(gitignorePath);

      // Should contain existing content
      expect(content).toContain("node_modules/");
      expect(content).toContain("*.log");

      // Should not duplicate existing rules
      const amazonqMatches = content.match(/\*\*\/\.amazonq\//g);
      expect(amazonqMatches).toHaveLength(1);

      // Note: **/.cursor/ appears in two different patterns: **/.cursor/ and **/.cursor/mcp.json
      // So we should see it mentioned at least twice when all rules are added
      const cursorMatches = content.match(/\*\*\/\.cursor\//g);
      expect(cursorMatches).toBeDefined();
      expect(cursorMatches!.length).toBeGreaterThanOrEqual(1);

      // Should add missing rules
      expect(content).toContain("**/.clinerules/");
      expect(content).toContain("**/CLAUDE.md");
    });

    it("should report correct number of added rules", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const existingContent = `# Generated by rulesync - AI tool configuration files
**/.amazonq/
**/.cursor/
**/.clinerules/`;
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, existingContent, "utf-8");

      await gitignoreCommand();

      // Should report that fewer rules were added since some already existed
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );

      // Get the number from the log call
      const logCall = vi
        .mocked(logger.success)
        .mock.calls.find((call) => typeof call[0] === "string" && call[0].includes("Added"));
      expect(logCall).toBeDefined();

      // Extract number and verify it's less than total possible rules
      const match = logCall![0].match(/Added (\d+) rules/);
      expect(match).toBeDefined();
      const addedCount = parseInt(match![1]!, 10);
      expect(addedCount).toBeLessThan(44); // Total rules minus the 3 already present
    });
  });

  describe("when all rules already exist", () => {
    it("should report that .gitignore is up to date", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      // Create content with all the rules that gitignoreCommand would add
      const allRulesContent = `# Generated by rulesync - AI tool configuration files
**/AGENTS.md
**/.agents/
**/.amazonq/
**/.augmentignore
**/.augment/rules/
**/.augment-guidelines
**/CLAUDE.md
**/.claude/memories/
**/.claude/commands/
**/.claude/agents/
**/.claude/settings.local.json
**/.mcp.json
**/modular-mcp.json
**/.clinerules/
**/.clineignore
**/.cline/mcp.json
**/.codexignore
**/.codex/
**/.cursor/
**/.cursorignore
**/.cursor/mcp.json
**/GEMINI.md
**/.gemini/memories/
**/.gemini/commands/
**/.gemini/subagents/
**/.github/copilot-instructions.md
**/.github/instructions/
**/.github/prompts/
**/.github/subagents/
**/.vscode/mcp.json
**/.junie/guidelines.md
**/.kiro/steering/
**/.aiignore
**/.opencode/memories/
**/.opencode/commands/
**/opencode.json
**/QWEN.md
**/.qwen/memories/
**/.roo/rules/
**/.rooignore
**/.roo/mcp.json
**/.roo/subagents/
**/.warp/
**/WARP.md`;
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, allRulesContent, "utf-8");

      await gitignoreCommand();

      expect(logger.success).toHaveBeenCalledWith(".gitignore is already up to date");

      // Content should remain unchanged
      const content = await readFileContent(gitignorePath);
      expect(content).toBe(allRulesContent);
    });
  });

  describe("logging behavior", () => {
    it("should log each added rule (excluding comments)", async () => {
      await gitignoreCommand();

      // Should log the count of added rules
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );

      // Should log each individual rule (not comments)
      expect(logger.info).toHaveBeenCalledWith("  **/.amazonq/");
      expect(logger.info).toHaveBeenCalledWith("  **/.cursor/");
      expect(logger.info).toHaveBeenCalledWith("  **/CLAUDE.md");

      // Should not log comment lines
      expect(logger.info).not.toHaveBeenCalledWith(
        expect.stringContaining("# Generated by rulesync"),
      );
    });

    it("should not log rules that are comments", async () => {
      await gitignoreCommand();

      // Get all info log calls
      const infoLogCalls = vi.mocked(logger.info).mock.calls;

      // None should contain comments (lines starting with #)
      for (const call of infoLogCalls) {
        if (typeof call[0] === "string") {
          expect(call[0]).not.toMatch(/^\s*#/);
        }
      }
    });
  });

  describe("error handling", () => {
    it("should handle file read errors", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const fs = await import("node:fs/promises");
      // Create a directory instead of a file to cause a read error
      await fs.mkdir(gitignorePath);

      await expect(gitignoreCommand()).rejects.toThrow();
    });

    it("should handle file write errors", async () => {
      const fs = await import("node:fs/promises");
      // Make the directory read-only to cause a write error
      await fs.chmod(testDir, 0o444);

      try {
        await expect(gitignoreCommand()).rejects.toThrow();
      } finally {
        // Restore permissions for cleanup
        await fs.chmod(testDir, 0o755);
      }
    });
  });

  describe("path handling", () => {
    it("should use correct .gitignore path based on current working directory", async () => {
      await gitignoreCommand();

      const gitignorePath = join(testDir, ".gitignore");
      expect(await fileExists(gitignorePath)).toBe(true);
    });
  });

  describe("content formatting", () => {
    it("should handle existing content with trailing whitespace", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const existingContent = "node_modules/\n*.log   \n   ";
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, existingContent, "utf-8");

      await gitignoreCommand();

      const content = await readFileContent(gitignorePath);

      // Should trim trailing whitespace before adding new content
      expect(content).toMatch(/\*\.log\n\n# Generated by rulesync/);
      expect(content).not.toContain("   \n\n");
    });

    it("should ensure proper line separation between existing and new content", async () => {
      const gitignorePath = join(testDir, ".gitignore");
      const existingContent = "node_modules/";
      const fs = await import("node:fs/promises");
      await fs.writeFile(gitignorePath, existingContent, "utf-8");

      await gitignoreCommand();

      const content = await readFileContent(gitignorePath);

      // Should have exactly two newlines between existing and new content
      expect(content).toMatch(/node_modules\/\n\n# Generated by rulesync/);
    });
  });
});
