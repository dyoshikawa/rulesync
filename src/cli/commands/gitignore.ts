import { join } from "node:path";
import { fileExists, readFileContent, writeFileContent } from "../../utils/file.js";
import { logger } from "../../utils/logger.js";

export const gitignoreCommand = async (): Promise<void> => {
  const gitignorePath = join(process.cwd(), ".gitignore");

  const rulesFilesToIgnore = [
    "# Generated by rulesync - AI tool configuration files",
    // AGENTS.md
    "**/AGENTS.md",
    "**/.agents/",
    // Amazon Q
    "**/.amazonq/",
    // Augment
    "**/.augmentignore",
    "**/.augment/rules/",
    "**/.augment-guidelines",
    // Claude Code
    "**/CLAUDE.md",
    "**/.claude/memories/",
    "**/.claude/commands/",
    "**/.claude/agents/",
    "**/.claude/settings.local.json",
    "**/.mcp.json",
    // Cline
    "**/.clinerules/",
    "**/.clineignore",
    "**/.cline/mcp.json",
    // Codex
    "**/.codexignore",
    "**/.codex/",
    // Cursor
    "**/.cursor/",
    "**/.cursorignore",
    "**/.cursor/mcp.json",
    // Gemini
    "**/GEMINI.md",
    "**/.gemini/memories/",
    "**/.gemini/commands/",
    "**/.gemini/subagents/",
    // GitHub Copilot
    "**/.github/copilot-instructions.md",
    "**/.github/instructions/",
    "**/.github/prompts/",
    "**/.github/subagents/",
    "**/.vscode/mcp.json",
    // Junie
    "**/.junie/guidelines.md",
    // Kiro
    "**/.kiro/steering/",
    "**/.aiignore",
    // OpenCode
    "**/.opencode/memories/",
    "**/.opencode/commands/",
    "**/opencode.json",
    // Qwen
    "**/QWEN.md",
    "**/.qwen/memories/",
    // Roo
    "**/.roo/rules/",
    "**/.rooignore",
    "**/.roo/mcp.json",
    "**/.roo/subagents/",
    // Warp
    "**/.warp/",
    "**/WARP.md",
    // Others
    "**/modular-mcp.json",
  ];

  let gitignoreContent = "";

  if (await fileExists(gitignorePath)) {
    gitignoreContent = await readFileContent(gitignorePath);
  }

  const linesToAdd: string[] = [];

  for (const rule of rulesFilesToIgnore) {
    if (!gitignoreContent.includes(rule)) {
      linesToAdd.push(rule);
    }
  }

  if (linesToAdd.length === 0) {
    logger.success(".gitignore is already up to date");
    return;
  }

  const newContent = gitignoreContent
    ? `${gitignoreContent.trimEnd()}\n\n${linesToAdd.join("\n")}\n`
    : `${linesToAdd.join("\n")}\n`;

  await writeFileContent(gitignorePath, newContent);

  logger.success(`Added ${linesToAdd.length} rules to .gitignore:`);
  for (const line of linesToAdd) {
    if (!line.startsWith("#")) {
      logger.info(`  ${line}`);
    }
  }
};
