import { writeFile } from "node:fs/promises";
import { join } from "node:path";
import { afterEach, beforeEach, describe, expect, it } from "vitest";
import { setupTestDirectory } from "../test-utils/index.js";
import { KiroIgnore, KiroIgnoreFile } from "./kiro-ignore.js";
import { RulesyncIgnore } from "./rulesync-ignore.js";

describe("KiroIgnore", () => {
  let testDir: string;
  let cleanup: () => Promise<void>;

  beforeEach(async () => {
    ({ testDir, cleanup } = await setupTestDirectory());
  });

  afterEach(async () => {
    await cleanup();
  });

  describe("constructor", () => {
    it("should create KiroIgnore with all three pattern types", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        gitignorePatterns: ["*.env", "node_modules/"],
        aiignorePatterns: ["*.csv", "*.db"],
        kirodeignorePatterns: ["!docs/**", "!*.md"],
      });

      expect(kiroIgnore.getGitignorePatterns()).toEqual(["*.env", "node_modules/"]);
      expect(kiroIgnore.getAiignorePatterns()).toEqual(["*.csv", "*.db"]);
      expect(kiroIgnore.getKirodeignorePatterns()).toEqual(["!docs/**", "!*.md"]);
      expect(kiroIgnore.getPatterns()).toEqual([
        "*.env",
        "node_modules/",
        "*.csv",
        "*.db",
        "!docs/**",
        "!*.md",
      ]);
    });

    it("should create KiroIgnore with empty patterns", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
      });

      expect(kiroIgnore.getGitignorePatterns()).toEqual([]);
      expect(kiroIgnore.getAiignorePatterns()).toEqual([]);
      expect(kiroIgnore.getKirodeignorePatterns()).toEqual([]);
      expect(kiroIgnore.getPatterns()).toEqual([]);
    });
  });

  describe("write", () => {
    it("should write three separate ignore files", async () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        gitignorePatterns: ["*.env", "secrets/"],
        aiignorePatterns: ["*.csv", "large-data/"],
        kirodeignorePatterns: ["!docs/**", "!README.md"],
      });

      await kiroIgnore.write();

      // Check that files were created and have expected content
      const { readFile } = await import("node:fs/promises");

      const gitignoreContent = await readFile(join(testDir, ".gitignore"), "utf-8");
      expect(gitignoreContent).toContain("# Generated by rulesync - Git ignore file");
      expect(gitignoreContent).toContain("*.env");
      expect(gitignoreContent).toContain("secrets/");

      const aiignoreContent = await readFile(join(testDir, ".aiignore"), "utf-8");
      expect(aiignoreContent).toContain("# Generated by rulesync - AI-specific exclusions");
      expect(aiignoreContent).toContain("*.csv");
      expect(aiignoreContent).toContain("large-data/");

      const kirodeignoreContent = await readFile(join(testDir, ".kirodeignore"), "utf-8");
      expect(kirodeignoreContent).toContain("# Generated by rulesync - Re-inclusion/allowlist");
      expect(kirodeignoreContent).toContain("!docs/**");
      expect(kirodeignoreContent).toContain("!README.md");
    });

    it("should skip writing in dry run mode", async () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        gitignorePatterns: ["*.env"],
        dryRun: true,
      });

      await kiroIgnore.write();

      // Files should not exist in dry run mode
      const { access, constants } = await import("node:fs/promises");

      // Check if files don't exist by attempting to access them
      let gitignoreExists = true;
      let aiignoreExists = true;
      let kirodeignoreExists = true;

      try {
        await access(join(testDir, ".gitignore"), constants.F_OK);
      } catch {
        gitignoreExists = false;
      }

      try {
        await access(join(testDir, ".aiignore"), constants.F_OK);
      } catch {
        aiignoreExists = false;
      }

      try {
        await access(join(testDir, ".kirodeignore"), constants.F_OK);
      } catch {
        kirodeignoreExists = false;
      }

      expect(gitignoreExists).toBe(false);
      expect(aiignoreExists).toBe(false);
      expect(kirodeignoreExists).toBe(false);
    });
  });

  describe("toRulesyncIgnore", () => {
    it("should convert KiroIgnore to RulesyncIgnore with combined content", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        gitignorePatterns: ["*.env", "node_modules/"],
        aiignorePatterns: ["*.csv", "data/"],
        kirodeignorePatterns: ["!docs/**", "!README.md"],
      });

      const rulesyncIgnore = kiroIgnore.toRulesyncIgnore();

      expect(rulesyncIgnore.getRelativeDirPath()).toBe(".");
      expect(rulesyncIgnore.getRelativeFilePath()).toBe(".rulesyncignore");

      const body = rulesyncIgnore.getBody();
      expect(body).toContain("*.env");
      expect(body).toContain("node_modules/");
      expect(body).toContain("*.csv");
      expect(body).toContain("data/");
      expect(body).toContain("!docs/**");
      expect(body).toContain("!README.md");
    });

    it("should handle empty patterns", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
      });

      const rulesyncIgnore = kiroIgnore.toRulesyncIgnore();
      const body = rulesyncIgnore.getBody();

      expect(body).toBe("");
    });
  });

  describe("fromRulesyncIgnore", () => {
    it("should create KiroIgnore from RulesyncIgnore with pattern distribution", () => {
      const rulesyncIgnore = new RulesyncIgnore({
        baseDir: testDir,
        relativeDirPath: ".rulesync/ignore",
        relativeFilePath: "test.md",
        body: [
          "*.env",
          "secrets/",
          "node_modules/",
          "*.csv",
          "large-data/",
          "!docs/**",
          "!README.md",
        ].join("\n"),
        fileContent: "Test content",
      });

      const kiroIgnore = KiroIgnore.fromRulesyncIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        rulesyncIgnore,
      });

      const gitignorePatterns = kiroIgnore.getGitignorePatterns();
      const aiignorePatterns = kiroIgnore.getAiignorePatterns();
      const kirodeignorePatterns = kiroIgnore.getKirodeignorePatterns();

      // Check pattern distribution
      expect(gitignorePatterns).toContain("*.env");
      expect(gitignorePatterns).toContain("secrets/");
      expect(gitignorePatterns).toContain("node_modules/");

      expect(aiignorePatterns).toContain("*.csv");
      expect(aiignorePatterns).toContain("large-data/");

      expect(kirodeignorePatterns).toContain("!docs/**");
      expect(kirodeignorePatterns).toContain("!README.md");

      // Should include defaults
      expect(gitignorePatterns).toContain("*.pem");
      expect(aiignorePatterns).toContain("*.sqlite");
      expect(kirodeignorePatterns).toContain("!.env.example");
    });

    it("should handle empty patterns", () => {
      const rulesyncIgnore = new RulesyncIgnore({
        baseDir: testDir,
        relativeDirPath: ".rulesync/ignore",
        relativeFilePath: "empty.md",
        body: "",
        fileContent: "",
      });

      const kiroIgnore = KiroIgnore.fromRulesyncIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        rulesyncIgnore,
      });

      // Should still have default patterns
      expect(kiroIgnore.getGitignorePatterns()).toContain("*.pem");
      expect(kiroIgnore.getAiignorePatterns()).toContain("*.csv");
      expect(kiroIgnore.getKirodeignorePatterns()).toContain("!docs/api/**");
    });
  });

  describe("fromFilePath", () => {
    it("should load KiroIgnore from valid JSON file", async () => {
      const kiroConfig: KiroIgnoreFile = {
        gitignore: ["*.env", "secrets/"],
        aiignore: ["*.csv", "data/"],
        kirodeignore: ["!docs/**", "!README.md"],
      };

      const filePath = join(testDir, "kiro-config.json");
      await writeFile(filePath, JSON.stringify(kiroConfig, null, 2));

      const kiroIgnore = await KiroIgnore.fromFilePath({ filePath });

      expect(kiroIgnore.getGitignorePatterns()).toEqual(["*.env", "secrets/"]);
      expect(kiroIgnore.getAiignorePatterns()).toEqual(["*.csv", "data/"]);
      expect(kiroIgnore.getKirodeignorePatterns()).toEqual(["!docs/**", "!README.md"]);
    });

    it("should handle partial configuration", async () => {
      const kiroConfig: KiroIgnoreFile = {
        gitignore: ["*.env"],
        // Missing aiignore and kirodeignore
      };

      const filePath = join(testDir, "partial-config.json");
      await writeFile(filePath, JSON.stringify(kiroConfig, null, 2));

      const kiroIgnore = await KiroIgnore.fromFilePath({ filePath });

      expect(kiroIgnore.getGitignorePatterns()).toEqual(["*.env"]);
      expect(kiroIgnore.getAiignorePatterns()).toEqual([]);
      expect(kiroIgnore.getKirodeignorePatterns()).toEqual([]);
    });

    it("should throw error for invalid JSON", async () => {
      const filePath = join(testDir, "invalid.json");
      await writeFile(filePath, "{ invalid json }");

      await expect(KiroIgnore.fromFilePath({ filePath })).rejects.toThrow(/Invalid JSON/);
    });

    it("should throw error for invalid schema", async () => {
      const invalidConfig = {
        gitignore: "not-an-array", // Should be array
      };

      const filePath = join(testDir, "invalid-schema.json");
      await writeFile(filePath, JSON.stringify(invalidConfig, null, 2));

      await expect(KiroIgnore.fromFilePath({ filePath })).rejects.toThrow(
        /Invalid Kiro ignore file format/,
      );
    });
  });

  describe("default patterns", () => {
    it("should provide default gitignore patterns", () => {
      const defaults = KiroIgnore.getDefaultGitignorePatterns();

      expect(defaults).toContain("*.pem");
      expect(defaults).toContain("*.key");
      expect(defaults).toContain(".env*");
      expect(defaults).toContain("node_modules/");
      expect(defaults).toContain("dist/");
      expect(defaults.length).toBeGreaterThan(5);
    });

    it("should provide default aiignore patterns", () => {
      const defaults = KiroIgnore.getDefaultAiignorePatterns();

      expect(defaults).toContain("*.csv");
      expect(defaults).toContain("*.sqlite");
      expect(defaults).toContain("internal-docs/");
      expect(defaults.length).toBeGreaterThan(3);
    });

    it("should provide default kirodeignore patterns", () => {
      const defaults = KiroIgnore.getDefaultKirodeignorePatterns();

      expect(defaults).toContain("!docs/api/**");
      expect(defaults).toContain("!.env.example");
      expect(defaults.length).toBeGreaterThan(2);
    });
  });

  describe("createWithDefaultPatterns", () => {
    it("should create KiroIgnore with default patterns", () => {
      const kiroIgnore = KiroIgnore.createWithDefaultPatterns({
        baseDir: testDir,
      });

      expect(kiroIgnore.getGitignorePatterns()).toContain("*.pem");
      expect(kiroIgnore.getAiignorePatterns()).toContain("*.csv");
      expect(kiroIgnore.getKirodeignorePatterns()).toContain("!docs/api/**");
    });

    it("should merge custom patterns with defaults", () => {
      const kiroIgnore = KiroIgnore.createWithDefaultPatterns({
        baseDir: testDir,
        gitignorePatterns: ["custom-secret.json"],
        aiignorePatterns: ["custom-data.xlsx"],
        kirodeignorePatterns: ["!custom-docs/**"],
      });

      const gitignorePatterns = kiroIgnore.getGitignorePatterns();
      const aiignorePatterns = kiroIgnore.getAiignorePatterns();
      const kirodeignorePatterns = kiroIgnore.getKirodeignorePatterns();

      // Should contain both defaults and custom patterns
      expect(gitignorePatterns).toContain("*.pem"); // default
      expect(gitignorePatterns).toContain("custom-secret.json"); // custom

      expect(aiignorePatterns).toContain("*.csv"); // default
      expect(aiignorePatterns).toContain("custom-data.xlsx"); // custom

      expect(kirodeignorePatterns).toContain("!docs/api/**"); // default
      expect(kirodeignorePatterns).toContain("!custom-docs/**"); // custom
    });

    it("should use default parameters if none provided", () => {
      const kiroIgnore = KiroIgnore.createWithDefaultPatterns();

      expect(kiroIgnore.getRelativeDirPath()).toBe(".");
      expect(kiroIgnore.getRelativeFilePath()).toContain(".kiro-ignore-config.json");
    });
  });

  describe("getSupportedFileNames", () => {
    it("should return the three Kiro ignore file names", () => {
      const supportedNames = KiroIgnore.getSupportedFileNames();

      expect(supportedNames).toContain(".gitignore");
      expect(supportedNames).toContain(".aiignore");
      expect(supportedNames).toContain(".kirodeignore");
      expect(supportedNames.length).toBe(3);
    });
  });

  describe("file content generation", () => {
    it("should generate gitignore content with headers and patterns", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        gitignorePatterns: ["custom-secret.json"],
      });

      const content = kiroIgnore["generateGitignoreContent"]();

      expect(content).toContain("# Generated by rulesync - Git ignore file");
      expect(content).toContain("# ───── Secrets & Credentials ─────");
      expect(content).toContain(".env");
      expect(content).toContain("*.key");
      expect(content).toContain("# ───── Custom patterns ─────");
      expect(content).toContain("custom-secret.json");
    });

    it("should generate aiignore content with AI-specific patterns", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        aiignorePatterns: ["custom-data.db"],
      });

      const content = kiroIgnore["generateAiignoreContent"]();

      expect(content).toContain("# Generated by rulesync - AI-specific exclusions");
      expect(content).toContain("*.csv");
      expect(content).toContain("*.sqlite");
      expect(content).toContain("# ───── Custom AI exclusions ─────");
      expect(content).toContain("custom-data.db");
    });

    it("should generate kirodeignore content with re-inclusion patterns", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        kirodeignorePatterns: ["!custom-docs/**"],
      });

      const content = kiroIgnore["generateKirodeignoreContent"]();

      expect(content).toContain("# Generated by rulesync - Re-inclusion/allowlist");
      expect(content).toContain("!docs/api/**");
      expect(content).toContain("!**/README.md");
      expect(content).toContain("# ───── Custom re-inclusions ─────");
      expect(content).toContain("!custom-docs/**");
    });

    it("should generate combined content for RulesyncIgnore", () => {
      const kiroIgnore = new KiroIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        gitignorePatterns: ["*.env"],
        aiignorePatterns: ["*.csv"],
        kirodeignorePatterns: ["!docs/**"],
      });

      const content = kiroIgnore["generateCombinedIgnoreContent"]();

      expect(content).toContain("# Kiro Three-File Ignore System");
      expect(content).toContain("## .gitignore patterns");
      expect(content).toContain("## .aiignore patterns");
      expect(content).toContain("## .kirodeignore patterns");
      expect(content).toContain("*.env");
      expect(content).toContain("*.csv");
      expect(content).toContain("!docs/**");
    });
  });

  describe("pattern distribution logic", () => {
    it("should correctly distribute patterns by content type", () => {
      const rulesyncIgnore = new RulesyncIgnore({
        baseDir: testDir,
        relativeDirPath: ".rulesync/ignore",
        relativeFilePath: "test.md",
        body: [
          "*.env", // Should go to gitignore (security)
          "secrets/", // Should go to gitignore (security)
          "node_modules/", // Should go to gitignore (build)
          "dist/", // Should go to gitignore (build)
          "*.csv", // Should go to aiignore (data)
          "large-data/", // Should go to aiignore (other)
          "!docs/**", // Should go to kirodeignore (re-inclusion)
          "!README.md", // Should go to kirodeignore (re-inclusion)
        ].join("\n"),
        fileContent: "Test content",
      });

      const kiroIgnore = KiroIgnore.fromRulesyncIgnore({
        baseDir: testDir,
        relativeDirPath: ".",
        rulesyncIgnore,
      });

      const gitignorePatterns = kiroIgnore.getGitignorePatterns();
      const aiignorePatterns = kiroIgnore.getAiignorePatterns();
      const kirodeignorePatterns = kiroIgnore.getKirodeignorePatterns();

      // Check security/build patterns went to gitignore
      expect(gitignorePatterns).toContain("*.env");
      expect(gitignorePatterns).toContain("secrets/");
      expect(gitignorePatterns).toContain("node_modules/");
      expect(gitignorePatterns).toContain("dist/");

      // Check data patterns went to aiignore
      expect(aiignorePatterns).toContain("*.csv");
      expect(aiignorePatterns).toContain("large-data/");

      // Check re-inclusion patterns went to kirodeignore
      expect(kirodeignorePatterns).toContain("!docs/**");
      expect(kirodeignorePatterns).toContain("!README.md");
    });
  });

  describe("tool name", () => {
    it("should have correct tool name", () => {
      expect(KiroIgnore.toolName).toBe("kiro");
    });
  });
});
