import { join } from "node:path";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

import { setupTestDirectory } from "../test-utils/test-directories.js";
import { fileExists, readFileContent, writeFileContent } from "../utils/file.js";
import { gitignore } from "./gitignore.js";

describe("gitignore", () => {
  let testDir: string;
  let cleanup: () => Promise<void>;

  beforeEach(async () => {
    ({ testDir, cleanup } = await setupTestDirectory());
    vi.spyOn(process, "cwd").mockReturnValue(testDir);
  });

  afterEach(async () => {
    vi.restoreAllMocks();
    await cleanup();
  });

  describe("new gitignore", () => {
    it("should create .gitignore when it does not exist", async () => {
      await gitignore();

      expect(await fileExists(join(testDir, ".gitignore"))).toBe(true);
    });

    it("should add rulesync header to new gitignore", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("# Generated by Rulesync");
    });

    it("should add rulesync entries to new gitignore", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.cursor/");
      expect(content).toContain("**/AGENTS.md");
    });
  });

  describe("existing gitignore", () => {
    it("should append rulesync entries to existing gitignore", async () => {
      await writeFileContent(join(testDir, ".gitignore"), "node_modules/\n");

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("node_modules/");
      expect(content).toContain("# Generated by Rulesync");
    });

    it("should preserve existing content", async () => {
      const existingContent = `# My gitignore
node_modules/
dist/
.env
`;
      await writeFileContent(join(testDir, ".gitignore"), existingContent);

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("# My gitignore");
      expect(content).toContain("node_modules/");
      expect(content).toContain("dist/");
      expect(content).toContain(".env");
    });

    it("should remove old rulesync header before adding new one", async () => {
      const oldContent = `node_modules/
# Generated by Rulesync
**/CLAUDE.md
**/.cursor/
`;
      await writeFileContent(join(testDir, ".gitignore"), oldContent);

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      const headerCount = (content.match(/# Generated by Rulesync/g) || []).length;
      expect(headerCount).toBe(1);
    });

    it("should remove legacy rulesync header", async () => {
      const oldContent = `node_modules/
# Generated by rulesync - AI tool configuration files
**/CLAUDE.md
`;
      await writeFileContent(join(testDir, ".gitignore"), oldContent);

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).not.toContain("# Generated by rulesync - AI tool configuration files");
      expect(content).toContain("# Generated by Rulesync");
    });

    it("should remove scattered rulesync entries", async () => {
      const scatteredContent = `node_modules/
**/CLAUDE.md
dist/
**/.cursor/
`;
      await writeFileContent(join(testDir, ".gitignore"), scatteredContent);

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("node_modules/");
      expect(content).toContain("dist/");
      // Rulesync entries should be grouped at the end
      const rulesyncHeaderIndex = content.indexOf("# Generated by Rulesync");
      const claudeIndex = content.lastIndexOf("**/CLAUDE.md");
      expect(claudeIndex).toBeGreaterThan(rulesyncHeaderIndex);
    });
  });

  describe("idempotency", () => {
    it("should not modify gitignore if already up to date", async () => {
      await gitignore();
      const firstContent = await readFileContent(join(testDir, ".gitignore"));

      await gitignore();
      const secondContent = await readFileContent(join(testDir, ".gitignore"));

      expect(firstContent).toBe(secondContent);
    });

    it("should be safe to call multiple times", async () => {
      await gitignore();
      await gitignore();
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      const headerCount = (content.match(/# Generated by Rulesync/g) || []).length;
      expect(headerCount).toBe(1);
    });
  });

  describe("content formatting", () => {
    it("should end with newline", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content.endsWith("\n")).toBe(true);
    });

    it("should separate existing content from rulesync block with blank line", async () => {
      await writeFileContent(join(testDir, ".gitignore"), "node_modules/\n");

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("node_modules/\n\n# Generated by Rulesync");
    });

    it("should handle empty existing gitignore", async () => {
      await writeFileContent(join(testDir, ".gitignore"), "");

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content.startsWith("# Generated by Rulesync")).toBe(true);
    });

    it("should handle gitignore with only whitespace", async () => {
      await writeFileContent(join(testDir, ".gitignore"), "   \n\n  ");

      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("# Generated by Rulesync");
    });
  });

  describe("rulesync entries", () => {
    it("should include Claude Code entries", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.claude/");
      expect(content).toContain("**/.mcp.json");
    });

    it("should include Cursor entries", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("**/.cursor/");
      expect(content).toContain("**/.cursorignore");
    });

    it("should include GitHub Copilot entries", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("**/.github/copilot-instructions.md");
      expect(content).toContain("**/.github/prompts/");
    });

    it("should include AGENTS.md entries", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("**/AGENTS.md");
      expect(content).toContain("**/.agents/");
    });

    it("should exclude .rulesync/.aiignore from gitignore", async () => {
      await gitignore();

      const content = await readFileContent(join(testDir, ".gitignore"));
      expect(content).toContain("!.rulesync/.aiignore");
    });
  });
});
