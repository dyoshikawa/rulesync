import { beforeEach, describe, expect, it, vi } from "vitest";
import { createMockConfigByTool } from "../../test-utils/index.js";
import type { ParsedRule } from "../../types/index.js";
import { loadIgnorePatterns } from "../../utils/ignore.js";
import { generateCopilotConfig } from "./copilot.js";

vi.mock("../../utils/ignore.js", () => ({
  loadIgnorePatterns: vi.fn(),
}));

describe("generateCopilotConfig", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  const mockConfig = createMockConfigByTool("copilot");

  const mockRule: ParsedRule = {
    frontmatter: {
      root: true,
      targets: ["copilot"],
      description: "Test rule",
      globs: ["**/*.ts"],
    },
    content: "Test rule content",
    filename: "test-rule",
    filepath: ".rulesync/test-rule.md",
  };

  it("should generate copilot config files", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({ patterns: [] });

    const outputs = await generateCopilotConfig([mockRule], mockConfig);

    expect(outputs).toHaveLength(1);
    expect(outputs[0]).toEqual({
      tool: "copilot",
      filepath: ".github/instructions/test-rule.instructions.md",
      content: expect.stringContaining('description: "Test rule"'),
    });
  });

  it("should generate .copilotignore when .rulesyncignore exists", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({
      patterns: ["*.test.md", "temp/**/*"],
    });

    const outputs = await generateCopilotConfig([mockRule], mockConfig);

    expect(outputs).toHaveLength(2);

    // Check rule file
    expect(outputs[0]?.filepath).toBe(".github/instructions/test-rule.instructions.md");

    // Check .copilotignore file
    expect(outputs[1]).toEqual({
      tool: "copilot",
      filepath: ".copilotignore",
      content: expect.stringContaining("# Generated by rulesync from .rulesyncignore"),
    });
    expect(outputs[1]?.content).toContain("# Note: .copilotignore is not officially supported");
    expect(outputs[1]?.content).toContain("*.test.md");
    expect(outputs[1]?.content).toContain("temp/**/*");
  });

  it("should not generate .copilotignore when no ignore patterns exist", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({ patterns: [] });

    const outputs = await generateCopilotConfig([mockRule], mockConfig);

    expect(outputs).toHaveLength(1);
    expect(outputs.every((o) => o.filepath !== ".copilotignore")).toBe(true);
  });

  it("should respect baseDir parameter", async () => {
    vi.mocked(loadIgnorePatterns).mockResolvedValue({
      patterns: ["*.test.md"],
    });

    const outputs = await generateCopilotConfig([mockRule], mockConfig, "/custom/base");

    expect(outputs).toHaveLength(2);
    expect(outputs[0]?.filepath).toBe(
      "/custom/base/.github/instructions/test-rule.instructions.md",
    );
    expect(outputs[1]?.filepath).toBe("/custom/base/.copilotignore");
  });
});
