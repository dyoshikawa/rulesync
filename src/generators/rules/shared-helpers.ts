import { join } from "node:path";
import type { Config, GeneratedOutput, ParsedRule, ToolTarget } from "../../types/index.js";
import { loadIgnorePatterns } from "../../utils/ignore.js";

export interface RuleGeneratorConfig {
  tool: ToolTarget;
  fileExtension: string;
  ignoreFileName: string;
  generateContent: (rule: ParsedRule) => string;
  pathResolver?: (rule: ParsedRule, outputDir: string) => string;
}

/**
 * Resolve output directory for a given tool and base directory
 */
export function resolveOutputDir(config: Config, tool: ToolTarget, baseDir?: string): string {
  return baseDir ? join(baseDir, config.outputPaths[tool]) : config.outputPaths[tool];
}

/**
 * Base generator function signature for consistency
 */
export type BaseGeneratorFunction = (
  rules: ParsedRule[],
  config: Config,
  baseDir?: string,
) => Promise<GeneratedOutput[]>;

/**
 * Helper to create outputs array and common processing pattern
 */
export function createOutputsArray(): GeneratedOutput[] {
  return [];
}

/**
 * Helper to add output with resolved directory path
 */
export function addOutput(
  outputs: GeneratedOutput[],
  tool: ToolTarget,
  config: Config,
  baseDir: string | undefined,
  relativePath: string,
  content: string,
): void {
  const outputDir = resolveOutputDir(config, tool, baseDir);
  outputs.push({
    tool,
    filepath: join(outputDir, relativePath),
    content,
  });
}

/**
 * Generic generator for rule files that handles both simple and complex path generation
 */
export async function generateRulesConfig(
  rules: ParsedRule[],
  config: Config,
  generatorConfig: RuleGeneratorConfig,
  baseDir?: string,
): Promise<GeneratedOutput[]> {
  const outputs: GeneratedOutput[] = [];

  // Generate rule files
  for (const rule of rules) {
    const content = generatorConfig.generateContent(rule);
    const outputDir = resolveOutputDir(config, generatorConfig.tool, baseDir);

    const filepath = generatorConfig.pathResolver
      ? generatorConfig.pathResolver(rule, outputDir)
      : join(outputDir, `${rule.filename}${generatorConfig.fileExtension}`);

    outputs.push({
      tool: generatorConfig.tool,
      filepath,
      content,
    });
  }

  // Generate ignore file if .rulesyncignore exists
  const ignorePatterns = await loadIgnorePatterns(baseDir);
  if (ignorePatterns.patterns.length > 0) {
    const ignorePath = baseDir
      ? join(baseDir, generatorConfig.ignoreFileName)
      : generatorConfig.ignoreFileName;

    const ignoreContent = generateIgnoreFile(ignorePatterns.patterns, generatorConfig.tool);

    outputs.push({
      tool: generatorConfig.tool,
      filepath: ignorePath,
      content: ignoreContent,
    });
  }

  return outputs;
}

/**
 * Generate ignore file content with standard header
 */
export function generateIgnoreFile(patterns: string[], tool: ToolTarget): string {
  const lines: string[] = [
    "# Generated by rulesync from .rulesyncignore",
    "# This file is automatically generated. Do not edit manually.",
  ];

  // Add tool-specific comment for unofficial support
  if (tool === "copilot") {
    lines.push("# Note: .copilotignore is not officially supported by GitHub Copilot.");
    lines.push("# This file is for use with community tools like copilotignore-vscode extension.");
  }

  lines.push("");
  lines.push(...patterns);

  return lines.join("\n");
}

/**
 * @deprecated Use generateRulesConfig with pathResolver instead
 * Compatibility wrapper for complex rule generators
 */
export interface ComplexRuleGeneratorConfig {
  tool: ToolTarget;
  fileExtension: string;
  ignoreFileName: string;
  generateContent: (rule: ParsedRule) => string;
  getOutputPath: (rule: ParsedRule, outputDir: string) => string;
}

/**
 * @deprecated Use generateRulesConfig with pathResolver instead
 * Legacy wrapper for complex rule generation
 */
export async function generateComplexRulesConfig(
  rules: ParsedRule[],
  config: Config,
  generatorConfig: ComplexRuleGeneratorConfig,
  baseDir?: string,
): Promise<GeneratedOutput[]> {
  // Convert to unified config format
  const unifiedConfig: RuleGeneratorConfig = {
    tool: generatorConfig.tool,
    fileExtension: generatorConfig.fileExtension,
    ignoreFileName: generatorConfig.ignoreFileName,
    generateContent: generatorConfig.generateContent,
    pathResolver: generatorConfig.getOutputPath,
  };

  return generateRulesConfig(rules, config, unifiedConfig, baseDir);
}
