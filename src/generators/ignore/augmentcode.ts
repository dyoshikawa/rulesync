import { join } from "node:path";
import type { Config, GeneratedOutput, ParsedRule } from "../../types/index.js";

export async function generateAugmentCodeIgnoreFiles(
  rules: ParsedRule[],
  config: Config,
  baseDir?: string,
): Promise<GeneratedOutput[]> {
  const outputs: GeneratedOutput[] = [];

  const augmentignoreContent = generateAugmentignoreContent(rules);
  const outputPath = baseDir || process.cwd();
  const filepath = join(outputPath, ".augmentignore");

  outputs.push({
    tool: "augmentcode",
    filepath,
    content: augmentignoreContent,
  });

  return outputs;
}

function generateAugmentignoreContent(rules: ParsedRule[]): string {
  const lines: string[] = [
    "# Generated by rulesync - AugmentCode ignore patterns",
    "# AugmentCode uses a two-tier approach: .gitignore first, then .augmentignore",
    "# This file provides Augment-specific exclusions and re-inclusions",
    "",
  ];

  // Add security and secrets exclusions
  lines.push(
    "# Security and Secrets (critical exclusions)",
    "# Environment files",
    ".env*",
    "",
    "# Private keys and certificates",
    "*.pem",
    "*.key",
    "*.p12",
    "*.crt",
    "*.der",
    "",
    "# SSH keys",
    "id_rsa*",
    "id_dsa*",
    "",
    "# AWS credentials",
    ".aws/",
    "aws-exports.js",
    "",
    "# API keys and tokens",
    "**/apikeys/",
    "**/*_token*",
    "**/*_secret*",
    "",
  );

  // Add build artifacts and dependencies
  lines.push(
    "# Build Artifacts and Dependencies",
    "# Build outputs",
    "dist/",
    "build/",
    "out/",
    "target/",
    "",
    "# Dependencies",
    "node_modules/",
    "venv/",
    "*.egg-info/",
    "",
    "# Logs",
    "*.log",
    "logs/",
    "",
    "# Temporary files",
    "*.tmp",
    "*.swp",
    "*.swo",
    "*~",
    "",
  );

  // Add large files and media
  lines.push(
    "# Large Files and Media",
    "# Binary files",
    "*.jar",
    "*.png",
    "*.jpg",
    "*.jpeg",
    "*.gif",
    "*.mp4",
    "*.avi",
    "*.zip",
    "*.tar.gz",
    "*.rar",
    "",
    "# Database files",
    "*.sqlite",
    "*.db",
    "*.mdb",
    "",
    "# Data files",
    "*.csv",
    "*.tsv",
    "*.xlsx",
    "",
  );

  // Add performance optimization patterns
  lines.push(
    "# Performance Optimization",
    "# Exclude files that are too large for effective AI processing",
    "**/*.{mp4,avi,mov,mkv}",
    "**/*.{zip,tar,gz,rar}",
    "**/*.{pdf,doc,docx}",
    "**/logs/**/*.log",
    "",
    "# But include small configuration files",
    "!**/config.{json,yaml,yml}",
    "",
  );

  // Add patterns from rules
  const rulePatterns = extractIgnorePatternsFromRules(rules);
  if (rulePatterns.length > 0) {
    lines.push("# Project-specific patterns from rulesync rules");
    lines.push(...rulePatterns);
    lines.push("");
  }

  // Add team collaboration patterns
  lines.push(
    "# Team Collaboration",
    "# Exclude personal IDE settings",
    ".vscode/settings.json",
    ".idea/workspace.xml",
    "",
    "# But include shared team settings",
    "!.vscode/extensions.json",
    "!.idea/codeStyles/",
    "",
    "# Exclude test fixtures with sensitive data",
    "tests/fixtures/real-data/**",
    "",
    "# Re-include important documentation",
    "!vendor/*/README.md",
    "!third-party/*/LICENSE",
    "",
  );

  return lines.join("\n");
}

function extractIgnorePatternsFromRules(rules: ParsedRule[]): string[] {
  const patterns: string[] = [];

  for (const rule of rules) {
    // Extract ignore patterns from rule globs
    if (rule.frontmatter.globs && rule.frontmatter.globs.length > 0) {
      for (const glob of rule.frontmatter.globs) {
        // Convert globs to ignore patterns where appropriate for AugmentCode
        if (shouldExcludeFromAugmentCode(glob)) {
          patterns.push(`# Exclude: ${rule.frontmatter.description}`);
          patterns.push(glob);
        }
      }
    }

    // Look for explicit AugmentCode ignore patterns in rule content
    const contentPatterns = extractAugmentCodeIgnorePatternsFromContent(rule.content);
    patterns.push(...contentPatterns);
  }

  return patterns;
}

function shouldExcludeFromAugmentCode(glob: string): boolean {
  // Determine if a glob pattern should be excluded from AugmentCode indexing
  const excludePatterns = [
    // Large generated files that slow indexing
    "**/assets/generated/**",
    "**/public/build/**",

    // Test fixtures with potentially sensitive data
    "**/tests/fixtures/**",
    "**/test/fixtures/**",
    "**/*.fixture.*",

    // Build outputs that provide little value for AI context
    "**/dist/**",
    "**/build/**",
    "**/coverage/**",

    // Configuration that might contain sensitive data
    "**/config/production/**",
    "**/config/secrets/**",
    "**/deploy/prod/**",

    // Internal documentation
    "**/internal-docs/**",
    "**/proprietary/**",
    "**/personal-notes/**",
    "**/private/**",
    "**/confidential/**",
  ];

  return excludePatterns.some((pattern) => {
    // Simple pattern matching for common cases
    const regex = new RegExp(pattern.replace(/\*\*/g, ".*").replace(/\*/g, "[^/]*"));
    return regex.test(glob);
  });
}

function extractAugmentCodeIgnorePatternsFromContent(content: string): string[] {
  const patterns: string[] = [];
  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();

    // Look for AugmentCode-specific ignore patterns
    if (trimmed.startsWith("# AUGMENT_IGNORE:") || trimmed.startsWith("# augmentignore:")) {
      const pattern = trimmed.replace(/^# (AUGMENT_IGNORE|augmentignore):\s*/, "").trim();
      if (pattern) {
        patterns.push(pattern);
      }
    }

    // Look for re-inclusion patterns (negation with !)
    if (trimmed.startsWith("# AUGMENT_INCLUDE:") || trimmed.startsWith("# augmentinclude:")) {
      const pattern = trimmed.replace(/^# (AUGMENT_INCLUDE|augmentinclude):\s*/, "").trim();
      if (pattern) {
        patterns.push(`!${pattern}`);
      }
    }

    // Look for performance-related exclusions mentioned in content
    if (trimmed.includes("large file") || trimmed.includes("binary") || trimmed.includes("media")) {
      const matches = trimmed.match(/['"`]([^'"`]+\.(mp4|avi|zip|tar\.gz|rar|pdf|doc|xlsx))['"`]/g);
      if (matches) {
        patterns.push(...matches.map((m) => m.replace(/['"`]/g, "")));
      }
    }
  }

  return patterns;
}
